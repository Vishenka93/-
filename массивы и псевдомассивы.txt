Основные методы для работы с массивами 
Это структура которая содержит элементы по порядку



		Методы которые работают с концом массива 
			pop()    удаляет последние элементы массива 
	const arr = [1, 2, 3, 6, 8];
	arr.pop();
	console.log(arr);    в консоли 8 теперь нет
     		

		Методы которые будет добавлять в конец массива 
	const arr = [1, 2, 3, 6, 8];
	arr.push(10);
	console.log(arr); и мы получаем 10 в самом конце 


		Перебор массива 
		const arr = [1, 2, 3, 6, 8];

	for (let i = 0; i < arr.length; i++) {
	console.log(arr[i]);
	} 

		Еще можно перебрать при помощи for of
	const arr = [1, 2, 3, 6, 8];

	for (let value of arr) {
	console.log(value);
	}     и получаем такой же результат 


			Length и его особенности для массивов

const arr = [1, 2, 3, 6, 8];


console.log(arr.length); получим 5 элементов 

Могут на собеседовании спросить, как соотносится между собой свойства length и порядковые номера внутри элементов этих массивов и ответ в том что 
LENGTH СВОЙСТВО СОСТОИТ ИЗ ПОСЛЕДНЕГО ИНДЕКСА КОТОРЫЙ ЕСТЬ У НАС В МАССИВЕ + 1 !!!!!!!!!!!!!!!!!!

		Есть моменты когда это может нарушиться 


	const arr = [1, 2, 3, 6, 8];

	arr[99] = 0;
	console.log(arr.length);    в консоли будет написано что у нас 100 элементов в массиве, хотя это не так 

	проверим этот массив const arr = [1, 2, 3, 6, 8];

					arr[99] = 0;
					console.log(arr.length);
					console.log(arr);   и мы получаем 94  пустых ячейки после 8 и это самое главное нарушение смысла нашего массива 
в том что наши элементы лежат не по порядку 


			Методы массивов которые больше всего используется в коде forEach();  и этот метод позволяет нам гибко перебрать
все элементы которые находятся внутри массива, он работает немного подругому потому что мы его можем настроить Он принемает в себя 
call-back function 

		const arr = [1, 2, 3, 6, 8];

		arr.forEach(function(item, i, arr) {
		console.log(`${i}: ${item} внутри массива ${arr}`);
		});
			в консоли получаем 
"0: 1 внутри массива 1,2,3,6,8"
"1: 2 внутри массива 1,2,3,6,8"
"2: 3 внутри массива 1,2,3,6,8"
"3: 6 внутри массива 1,2,3,6,8"
"4: 8 внутри массива 1,2,3,6,8"

И эта функция будет выполянться каждый раз для каждого элемента массива, тоесть метод forEach проходится по каждому элементу массива и 
применяет функцию для каждого из элементов и эту call-back функцию мы можем очень гибко настроить, она может в себя принемать 3 аргумента 
1. Это собственно тот элемент который мы сейчас перебираем [1, 2, 3, 6, 8], назвать можно как угодно нов моем примере это item 
2. Аргумент это номер по порядку в моем случае это i
3. Аргумент это ссылка на тот массив который мы перебираем в моем случае это arr 

			Call-back функция служит для того чтобы выполниться строго после опред действий !!!!!!




			Когда использовать forEach а когда обычный цыкл или перебор ???????????
Обычно используют forEach но у метода for of есть один плюс, то что у метода for of есть ключевые слова break и continue ( когда нам надо будет остановить цыкл)
либо полностью либо пропустить одно повторение, а в forEach мы уже не сможем его остановить на каком то этапе. Это единственное отличие 


				В массиве есть еще несколько перебирающих методов но они уже будут заниматься трансформацией массивов
					К УРОКУ ПРИКРЕПЛЕНА ТАБЛИЧКА !!!!!!!!!!!!!!!!!!!!!!!!



					Еще разберем 3 метода

const str = prompt('', '');

const products = str.split(', '); внутри скобках мы пичем через какой разделитель будут товары в строке (мы должны это четко знать)
console.log(products); 


			Обратная операция когда на основании массива можем сформировать большую строку 



console.log(products.join('; ')); тоесть оюъединение элементов массива в скобках должны указать тот разделитель через который они будут выводиться
эти элементы массива на страничку


		Последний метод sort();

			products.sort(); все сортируется в алфавитном порядке 
но у его есть одна особенность, он всегда сортирует элементы которые находятся в массиве как строки 
а если проверить на числах заметим очень интересную вещь 
const arr = [2, 13, 26, 8, 10];

arr.sort();
console.log(arr);


в консоли получили [10, 13, 2, 26, 8]  метод sort сортирует все как строки оно сортируется по первому символу 
но это мы можем избежать, метод sort внутрь может так же принимать call-back функц3ию, мы можем сказать как именно сортировать этот массив 
		Шаблон который будет часто встречаться 
const arr = [2, 13, 26, 8, 10];

arr.sort(compareNum);
console.log(arr);

function compareNum(a, b) { !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
return a - b;
}     и в консоли числа отсортировались правильно 


			









